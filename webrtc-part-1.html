<html dir="ltr" lang="en"><head><meta charset="UTF-8" /><meta content="width=device-width, initial-scale=1, maximum-scale=1" name="viewport" /><meta content="I did a little experiment with WebRTC and a CFD (Computational Fluid Dynamics) solver I wrote. I wanted to see what could be done with webRTC and browser parallel computing. First, I needed a problem that was computationally intense and suitable to parallelization. CFD suited that class of problems and plus, coming from mechanical engineering, it was a type of problem I was decently familiar with." name="description" /><title>WebRTC Parallel Processing with a 2D partial difference equations solver (part-1)</title><link href="assets/css/main.css" rel="stylesheet" /><script async="defer" data-domain="flaviosousa.co" src="https://plausible.io/js/plausible.js"></script></head><body><header><div class="container"><div class="row"><div class="col-12 col-sm-4 col-md-3"><p class="h1"><strong><a href="/">flaviosousa.co</a></strong></p><p>Software Engineer</p></div><div class="col-12 col-sm-4 col-md-5"><div class="about"><p><i>Personal website.<br />Past projects, bit of blogging.</i></p></div></div><div class="col-12 col-sm-4"><div class="social-links"><a href="https://medium.com/@fjsousa" target="_blank"><img src="assets/img/icon-medium.svg" /></a><a href="https://www.linkedin.com/in/fjsousa/" target="_blank"><img src="assets/img/icon-linkedin.svg" /></a><a target="_blank"><img src="assets/img/icon-twitter.svg" /></a><a href="https://github.com/fjsousa" target="_blank"><img src="assets/img/icon-github.svg" /></a></div></div></div></div></header><main><div class="container"><div class="row"><div class="col-12 col-sm-6 col-sm-push-3"><article class="article-body"><h1>WebRTC Parallel Processing (part-1)</h1><p>I did a little experiment with WebRTC and a CFD (Computational Fluid Dynamics) solver I wrote. I wanted to see what could be done with webRTC and browser parallel computing. First, I needed a problem that was computationally intense and suitable to parallelization. CFD suited that class of problems and plus, coming from mechanical engineering, it was a type of problem I was decently familiar with.</p><p>CFD is a class of numerical methods to solve differential equations from fluid flow problems. We want to solve a given set of equation to compute several fields like flow velocity, temperature and other physical properties.</p><p>The methods used in this type of numerical analysis are iterative, meaning that you'll have to compute several solutions, each one function of and closer to the final solution than the previous. When you use parallel computing techniques, you end up with a lot of communication between nodes at each iteration. This way, the communication speed quickly becomes the bottleneck in the process.</p><p>In this first post, I'll write about the solver itself.  In a second post, I'll write about how I used WebRtC to distribute the computation across several browsers. In a third post, I'll write about performance considerations.</p><h2>The Poisson Equation</h2><p>The equation I'm solving is in the form of</p><p></p><div class="equation">  $$ \left(\frac{\partial ^2 }{\partial x^2 } + \frac{\partial^2 }{\partial y^2 } \right) U(x,y) = b $$  </div><p></p><p>this equation describes aspects of physical behaviour in, for instance, heat transfer and fluid flow. Fluid flow problems are based in the Navier Stokes equation. Solving the poisson term is an important step of a Navier Stokes solver as it  makes up a large amount of the computing time.</p><p>In the equation above, the term <em>U(x,y)</em> represents the field we are interested in computing. Usually there's no analytical solution to get <em>U</em>, hence the need to use numerical methods. However if we want to test the solver, we can go the other way around. We Start with a given <em>U</em> function,  and replace it in the equation above.</p><p>Considering a rectangular domain of width <em>w</em> and height <em>h</em>, we have for instance:</p><p></p><div class="equation">  $$ U(x,y) = cos \left( \pi \left( \frac{1}{2} - \frac{x}{w} \right) \right) sin \left( \pi \frac{y}{h} \right) $$  </div><p></p><p>The field <em>U</em> plotted in <em>x</em>, <em>y</em> looks something like this:</p><p><img alt="Analytical Field" src="assets/img/webrtc-part-1/analitical.png" title="Analytical Field" /></p><p>Replacing the first equation with this <em>U</em> function we get:</p><p></p><div class"equation"="">  $$ \left(\frac{\partial ^2}{\partial x^2} + \frac{\partial ^2}{\partial y^2} \right) U(x,y) = U(x,y) \left( -\frac{\pi^2}{h^2} - \frac{\pi^2}{w^2}  \right) .$$ <p></p><p>It's important to notice that our <em>U</em> function doesn't have any practical physical meaning. It's just a way to test a solver of a differential equation, of which we have an analytical solution.</p><h2>Numerical Model</h2><p>The next step is to discretize the equation and obtain an algebraic formula for <em>U</em> that we can code. I won't go into details about the deduction because this is an extensive topic but you can find many references all over the internet, <a href="http://www.ece.utah.edu/~ece6340/LECTURES/Feb1/Nagel20201220-20Solving20the20Generalized20Poisson20Equation20using%20FDM.pdf">like this one</a>.</p><p>Basically, the idea is to approximate the derivative in an array of points in the domain of the solution. The points are equally spread in <em>x</em> and <em>y</em> like in the image bellow</p><p><img alt="points" src="assets/img/webrtc-part-1/domain.png" title="Points" /></p><p>In the image, <em>h</em> is the distance between two points. In the x and y direction, this distance will be called <em>Δx</em> and <em>Δy</em>, respectively. Here's the numerical formula for our equation:</p><p></p><div class="equation">  $$u_{i,j} = - \frac{1}{-2/\Delta x^2 -2/ \Delta y^2} \left( \frac{u_{i,j-1} + u_{i,j+1}}{\Delta x^2} + \frac{u_{i+1,j} + u_{i-1,j} } {\Delta y^2} - U(x_j,y_i) \left( -\frac{\pi^2}{h^2} - \frac{\pi^2}{w^2}  \right) \right).$$  <div><p></p><p>To compute the field <em>u</em> we follow this procedure: we start with all points set to <em>u = 0</em> and compute <em>u'</em> for every point. We then repeat the process, computing the new values of <em>u'</em>, but now using the old values we computed earlier. The process is repeated until there is no significant difference between the new values and the old ones.</p><h2>Javascript Implementation</h2><p>I implemented the solver in node first so that I could have a version to test in my local machine. In CFD testing is an important step and there's two steps to accept a numerical solution as valid. First you have to check if the numerical method is being solved correctly. This step is known as verification. Secondly, you have to check if the solution compares well with the equations. This is known as validation. This two steps are implemented in a small test suit. You can find the solver on a <a href="//github.com/fjsousa/poisson-solver">github repository</a>.</p><p>Here's a walkthrough of the solver:</p><p>To install it just run</p><pre><code><div>  npm install fjsousa/poisson-solver

</div></code></pre><p>Then, require and instantiate the solver:</p><pre><code class="Javascript"><div>  <span class="hljs-keyword">var</span> Poisson = <span class="hljs-built_in">require</span>(<span class="hljs-string">'poisson-solver'</span>);

  <span class="hljs-comment">//Set conditions</span>
  <span class="hljs-keyword">var</span> conditions = {
    <span class="hljs-attr">w</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">h</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">n</span>: <span class="hljs-number">50</span>,
    <span class="hljs-attr">m</span>: <span class="hljs-number">50</span>
  };

  <span class="hljs-comment">//Initialize solver</span>
  <span class="hljs-keyword">var</span> poisson = <span class="hljs-keyword">new</span> Poisson(conditions);


</div></code></pre><p>Here, <code>w</code> and <code>h</code> are the width and height of the domain. In this case, we are choosing an unitary value for both. <code>n</code> and <code>m</code> are the number of cells in the dimensions <em>x</em> and <em>y</em>.</p><p>Now we need to set the boundary conditions. According to our analytical solution, the value of the edges of the domain are zero, so we'll create 4 arrays with zero elements, for the north, south, east and west boundaries:</p><pre><code class="Javascript"><div>  <span class="hljs-keyword">var</span> N = [];
  <span class="hljs-keyword">var</span> S = [];
  <span class="hljs-keyword">var</span> E = [];
  <span class="hljs-keyword">var</span> W = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; conditions.n; i++) {
    N[i] = S[i] = E[i] = W[i] = <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">//Set Dirichlet boundary conditions to zero</span>
  poisson.setBoundaryConditions(N, S, E, W);


</div></code></pre><p>Now we are ready to start the solver. We call the method poisson.solver and just have to define the maximum number of iterations and the final residue. The residue is a measurement of the difference between two consecutive <em>u</em> fields. The smaller the residue, the closer the solution is to a final solution.</p><pre><code class="Javascript"><div>  <span class="hljs-keyword">var</span> maxItterations = <span class="hljs-number">100000000</span>;
  <span class="hljs-keyword">var</span> maxResidue = <span class="hljs-number">1E-9</span> ;

  <span class="hljs-keyword">var</span> output = poisson.solver( maxItterations, maxResidue);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Solver converged with'</span>, output.iterations, <span class="hljs-string">'iterations and'</span>, output.residue, <span class="hljs-string">'residue.'</span>);

</div></code></pre><h2>Visualization</h2><p>The solver converges with 6100 iterations a residue of 9.988143389726145e-10.</p><pre><code class="bash"><div>  Solver: iteration <span class="hljs-comment"># 6200 with residue of 2.321164929065117e-9</span>
  Solver: iteration <span class="hljs-comment"># 6300 with residue of 1.8896603438688794e-9</span>
  Solver: iteration <span class="hljs-comment"># 6400 with residue of 1.5383724641902796e-9</span>
  Solver: iteration <span class="hljs-comment"># 6500 with residue of 1.252389003936899e-9</span>
  Solver: iteration <span class="hljs-comment"># 6600 with residue of 1.0195698719555473e-9</span>
  Solver converged with 6610 iterations and 9.988143389726145e-10 residue.

</div></code></pre><p>We can visualize the solution using the print method. This writes a <em>n x m</em> table wich you can load in a plotting software. I would recommend <a href="http://home.gna.org/veusz/">veusz</a>.</p><pre><code class="Javascript"><div>  <span class="hljs-comment">//Print solution</span>
  poisson.print(<span class="hljs-string">'./field.txt'</span>, poisson.u.old);

</div></code></pre><p><img alt="Numerical Field" src="assets/img/webrtc-part-1/numerical.png" title="Numerical" /></p><p>And that's it. In the next post, I'll show you how I developed from this single program poisson solver and distributed it among several browser tabs.</p></div></div></div></article></div></div></div></main><a class="back-to-top" href="#"></a></body><script src="assets/js/main.js" type="text/javascript"></script><script src="assets/js/rags.js" type="text/javascript"></script><script src="assets/js/fgm-main.js" type="text/javascript"></script></html>