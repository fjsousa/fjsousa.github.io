<html dir="ltr" lang="en"><head><meta charset="UTF-8" /><meta content="width=device-width, initial-scale=1, maximum-scale=1" name="viewport" /><meta content="In this blog post, I&apos;ll show you two Cellular Automata algorithms used in Forest Fire Simulation. The models differ in the way they use the GPU architecture to boost performance. The first model was implemented in a trivial way, without much concern for the unique memory access pattern of the GPU. The second algorithm addresses this issue and outperforms the first by two orders of magnitude." name="description" /><title>Forest Fires and Parallel Cellular Automata, going from 8x to 240x faster with GPUs</title><link href="assets/css/main.css" rel="stylesheet" /><script async="defer" data-domain="flaviosousa.co" src="https://plausible.io/js/plausible.js"></script></head><body><header><div class="container"><div class="row"><div class="col-12 col-sm-4 col-md-3"><p class="h1"><strong><a href="/">flaviosousa.co</a></strong></p><p>Software Engineer</p></div><div class="col-12 col-sm-4 col-md-5"><div class="about"><p><i>Personal website.<br />Past projects, bit of blogging.</i></p></div></div><div class="col-12 col-sm-4"><div class="social-links"><a href="https://medium.com/@fjsousa" target="_blank"><img src="assets/img/icon-medium.svg" /></a><a href="https://www.linkedin.com/in/fjsousa/" target="_blank"><img src="assets/img/icon-linkedin.svg" /></a><a target="_blank"><img src="assets/img/icon-twitter.svg" /></a><a href="https://github.com/fjsousa" target="_blank"><img src="assets/img/icon-github.svg" /></a></div></div></div></div></header><main><div class="container"><div class="row"><div class="col-12 col-sm-6 col-sm-push-3"><article class="article-body"><h1>Forest Fires and Parallel Cellular Automata, going from 8x to 240x faster with GPUs</h1><p>Forest fire numerical models use Cellular Automata (CA) to simulate fire propagation. A grid or mesh of the terrain is provided, along with maps for parameters like fuel properties, wind speed, humidity and others. The CA is basically a way to propagate an ignition state, based on minimum travel times, between adjacent cells.</p><p>Other methods exist, like vector based methods, that compute the position of the fire front in consecutive time steps, or partial differences equation (PDE), that allow for a two way coupling of the fire model and the weather models.</p><p>Although the last type is much more accurate, the first two are the <em>de facto</em> tools for fire modeling due to the compromise between computing speed and accuracy.</p><p>In this blog post, I'll show you two versions of a CA model, a trivial and a parallel version I developed during my Masters. Both versions were ported to <a href="https://en.wikipedia.org/wiki/CUDA">Nvidia GPUs</a> with the aim of speeding up the existing single core implementation.</p><p>Initially, a direct, naive port was attempted which wasn't very performant. This lead me to reformulate the algorithm so that it was fully parallel and therefore, more suitable to the many-core architecture of the GPU.</p><p>Performance increase was only achieved with a rethinking of the algorithm, not by tweaking and fine tunning the GPU parameters of a flawed approach.</p><h2>Naive algorithm</h2><p>The existing algorithm was the following:</p><ul><li>An outer loop iterates over time and an inner loop iterates in space, over the rows and columns of the terrain grid.</li><li>The inner loop looks for active cells in a map of ignition times and propagates the fire outwards, to each one of the 8 neighbours.</li></ul><p><img alt="Outer propagation" src="assets/img/fgm/outer.png" title="Outer Propagation" /></p><ul><li>The ignition time of each neighbour is computed with the formula below. The ignition map is then updated:</li></ul><p></p><div class="equation"> $$ t + \frac{l}{ROS}$$ </div><p></p><p>where <em>ROS</em> is the <strong>R</strong>ate <strong>O</strong>f <strong>S</strong>pread, basically the flame speed in the neighbour direction, function of wind, moisture, terrain, etc; <em>l</em> is the distance between cells and <em>t</em> is the time in the central cell.</p><p></p><div class="fgm-wrapper">   <canvas height="400" id="fgm-serial" width="400">Consider updating your browser.</canvas> </div> <button class="actionbutton" onclick="dumb.run()">â–º</button><p></p><p>If you press <strong>Run</strong>, you'll see an animation of the fire propagation with the naive version of the CA. Notice that each square represents a portion of the terrain and the colour is just a linear scale that maps to ignition time. The scale goes from blue, to red, white is the starting point and black means the cell is unburned.</p><p>This is the JavaScript code that runs the spatial loop. If you inspect this page, you'll see a very similar code:</p><pre><code class="Javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">naiveSpatialLoop</span>(<span class="hljs-params"></span>)</span>{

   t = tn;
   tn = <span class="hljs-literal">Infinity</span>;


   <span class="hljs-comment">//Spatial loop that looks for active cells,</span>
   <span class="hljs-comment">//ie, cells with ignition time = t</span>
   <span class="hljs-keyword">for</span> ( row = <span class="hljs-number">0</span>; row &lt; rows; row++){
     <span class="hljs-keyword">for</span> ( col = <span class="hljs-number">0</span>; col &lt; cols; col++){
       <span class="hljs-keyword">var</span> idx = col + cols*row;

       <span class="hljs-comment">//Update tn, so that tn is the minimum</span>
       <span class="hljs-comment">//ignition time for all cells,</span>
       <span class="hljs-comment">//in a given iteration</span>
       <span class="hljs-keyword">if</span> ( ignitionMap[idx] &gt; t &amp;&amp;
         tn &gt; ignitionMap[idx] ){

         tn = ignitionMap[idx];
         <span class="hljs-keyword">continue</span>;
       }

       <span class="hljs-comment">//skips cells that already burned</span>
       <span class="hljs-keyword">if</span> ( ignitionMap[idx] !== t )
         <span class="hljs-keyword">continue</span>;

       <span class="hljs-comment">//propagate fire for all 8 neighours</span>
       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">8</span>; n++){

         <span class="hljs-comment">//neighbour index calc</span>
         <span class="hljs-keyword">var</span> ncol = col + ncols[n];
         <span class="hljs-keyword">var</span> nrow = row + nrows[n];
         <span class="hljs-keyword">var</span> nidx = ncol + nrow*cols;

         <span class="hljs-comment">//Check if neighbour is inbound</span>
         <span class="hljs-keyword">if</span> ( !(nrow &gt;= <span class="hljs-number">0</span> &amp;&amp; nrow &lt; rows &amp;&amp;
           ncol &gt;= <span class="hljs-number">0</span> &amp;&amp; ncol &lt; cols) )
           <span class="hljs-keyword">continue</span>;

         <span class="hljs-comment">// skip if cell has already burned</span>
         <span class="hljs-keyword">if</span> ( ignitionMap[nidx] &lt; t )
           <span class="hljs-keyword">continue</span>;

         <span class="hljs-comment">//Compute neighbour cell ignition time,</span>
         <span class="hljs-comment">//based on the propagation speed</span>
         <span class="hljs-comment">//tcell = t + cell dist / flame_speed</span>
         igntime = t + ndist[n] / ROS;


         <span class="hljs-comment">//Update ignition time in the map only</span>
         <span class="hljs-comment">//if the the current time is smaller</span>
         <span class="hljs-keyword">if</span>(igntime &lt; ignitionMap[nidx]){
           ignitionMap[nidx] = igntime;
         }

         <span class="hljs-comment">//Update tn</span>
         <span class="hljs-keyword">if</span>( igntime &lt; tn )
           tn = igntime;
       }
     }
   }
 }
</code></pre><p>As I said, porting this algorithm to GPUs in a straightforward way resulted in very poor performance. I associated each cell with a GPU thread and ended up with threads writing in each other's memory and dealling with race conditions.</p><p>Also, the process doesn't have a great degree of parallelism because at each time step, very few cells are actually propagating and thus, require computation. Here's the speedups for several scenarios with different values for wind, fuel and moisture:</p><p><img alt="Outer propagation" src="assets/img/fgm/dumb.png" title="Outer Propagation" /></p><p>As you can see, very far from the two orders of magnitude in performance increase you usually get with GPUs.</p><h2>Smarter approach</h2><p>The algorithm we've seen mimics the way fire propagates in real life, propagating the fire to adjacent cells, one at the time.</p><p>Ignition times in surrounding cells are calculated, as we have seen, like this:</p><pre><code class="Javascript">
  igntime = t + ndist[n] / ROS;

  <span class="hljs-keyword">if</span>(igntime &lt; ignitionMap[nidx]){
    ignitionMap[nidx] = igntime;
  }
</code></pre><p>During the process, the ignition time in each cell is continuously updated, so that if two cells propagate to the same cell, the minimum time of the two is considered and stored as the true ignition time.</p><p>Looking at the problem in another way, what we have is a condition that can be stated as follows: the ignition time of each cell, is always the minimum of the set of ignition times accounted from the 8 surrounding cells.</p><p>From this, instead of computing outward ignition times at each neighbour, I compute the ignition time at the inner cell.</p><p><img alt="Outer propagation" src="assets/img/fgm/inner.png" title="Outer Propagation" /></p><p>But now the question is, how can I compute ignition times from cells that haven't burned yet?</p><p>The solution is to do it iteratively, ie, to start from a random ignition map and compute each new map function of the previous one, until there is virtually no difference between any two consecutive ignition maps.</p><p></p><div class="fgm-wrapper">   <canvas height="400" id="fgm-parallel" width="400">Consider updating your browser.</canvas> </div> <button class="actionbutton" onclick="smart.run()">â–º</button><p></p><p>This is how the spatial loop looks like:</p><pre><code class="Javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">smartSpatialLoop</span>(<span class="hljs-params"></span>)</span>{

  <span class="hljs-keyword">for</span> ( row = <span class="hljs-number">0</span>; row &lt; rows; row++){
    <span class="hljs-keyword">for</span> ( col = <span class="hljs-number">0</span>; col &lt; cols; col++){
      <span class="hljs-keyword">var</span> idx = col + cols*row;

      <span class="hljs-comment">//skip ignition cell</span>
      <span class="hljs-keyword">if</span> (ignitionMap[idx] === <span class="hljs-number">0</span>)
        <span class="hljs-keyword">continue</span>;

      <span class="hljs-keyword">var</span> minArray = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">8</span>; n++){

        <span class="hljs-comment">//neighbour index calc</span>
        <span class="hljs-keyword">var</span> ncol = col + ncols[n];
        <span class="hljs-keyword">var</span> nrow = row + nrows[n];
        <span class="hljs-keyword">var</span> nidx = ncol + nrow*cols;

        <span class="hljs-comment">//Check if neighbour is inbound</span>
        <span class="hljs-keyword">if</span> ( !(nrow &gt;= <span class="hljs-number">0</span> &amp;&amp; nrow &lt; rows
          &amp;&amp; ncol &gt;= <span class="hljs-number">0</span> &amp;&amp; ncol &lt; cols) )
          <span class="hljs-keyword">continue</span>;

        <span class="hljs-comment">//compute ignition time considering that the</span>
        <span class="hljs-comment">//flame moves from the neighbour to the center cell</span>
        <span class="hljs-keyword">var</span> igntime = ignitionMap[nidx]
          + ndist[n] / rosmap[nidx];
        minArray.push(igntime);

      }
      <span class="hljs-comment">//associate the minimum of the ignition times</span>
      <span class="hljs-comment">//to the ignition time of the center cell</span>
      ignitionMap[idx] = <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-literal">null</span>, minArray);

    }
  }

}</code></pre><p>The algorithm is much more efficient because I no longer spend most of the time looking for empty cells. Also, because of its parallelism, there's no longer race conditions and consequent serialization. The performance gains are around two orders of magnitude.</p><p><img alt="Outer propagation" src="/assets/img/fgm/smart.png" title="Outer Propagation" /></p><p>The two models side by side, with the same iteration interval of 100ms. Notice that the conditions are random, so each time you refresh the page, you'll get a slightly different simulation:</p><p></p><div class="fgm-wrapper" style="display:flex;justify-content:center;align-items:center;width:90%;">   <canvas height="250" id="fgm-parallel-twin" width="250">Consider updating your browser.</canvas>   <canvas height="250" id="fgm-serial-twin" width="250">Consider updating your browser.</canvas> </div> <button class="actionbutton" onclick="smart2.run();dumb2.run();">â–º</button><p></p><p>And that's it. If you want to know more just follow the link and read the <a href="assets/docs/sousa-etall.pdf" target="_blank">white paper</a>.</p></article></div></div></div></main><a class="back-to-top" href="#"></a></body><script src="assets/js/main.js" type="text/javascript"></script><script src="assets/js/rags.js" type="text/javascript"></script><script src="assets/js/fgm-main.js" type="text/javascript"></script></html>